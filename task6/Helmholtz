# coding: utf-8
#
# Solving Helmhotz equation with FEniCS
# Author: Juan Luis Cano Rodr√≠guez <juanlu@pybonacci.org>
# Inspired by: http://jasmcole.com/2014/08/25/helmhurts/
#https://fenicsproject.org/olddocs/dolfin//1.3.0/python/demo/documented/neumann-poisson/python/documentation.html
#https://fenicsproject.org/olddocs/dolfin//1.3.0/python/demo/documented/singular-poisson/python/documentation.html
import sys
import numpy as np
from dolfin import *
from fenics import *
from mshr import *
from math import fabs



from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
import scipy.misc
import matplotlib.tri as tri
from images2gif import writeGif

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.animation
import numpy as np
from PIL import Image, ImageChops
import string



def helmgoltz_1(u_D, f, alpha):
    # Boundary conditions
    def boundary(x, on_boundary):
        return on_boundary 

    bc = DirichletBC(V, u_D, boundary)

    # Equation
    u = TrialFunction(V)
    v = TestFunction(V)
    a = (alpha*inner(u, v) + inner(nabla_grad(u), nabla_grad(v))) * dx
    L = f*v*dx

    # Solve system
    u = Function(V)
    solve(a == L, u, bc)

    # error 
    error_L2 = errornorm(u_D, u, 'L2')
    vertex_values_u_D = u_D.compute_vertex_values(mesh)
    vertex_values_u = u.compute_vertex_values(mesh)
    error_C = np.max(np.abs(vertex_values_u - vertex_values_u_D))
    print("L2_error=", error_L2)
    print("C_error=", error_C)

        
    # Plot and export solution
    plot(u)
    #plot(mesh)
    file = File("helmhurts.pvd")
    file << u
    return u

def helmgoltz_2(u_D, f, g, alpha):
    tol = 1E-3

    def boundary_D(x, on_boundary):
	return on_boundary and fabs(x[0]*x[0]+x[1]*x[1]-1.0) < tol
	
    bc = DirichletBC(V, u_D, boundary_D)

    # Equation
    u = TrialFunction(V)
    v = TestFunction(V)
    a = (alpha*inner(u, v) + inner(nabla_grad(u), nabla_grad(v))) * dx
    L = f*v*dx - g*v*ds

    # Solve system
    u = Function(V)
    solve(a == L, u, bc)

    # error 
    error_L2 = errornorm(u_D, u, 'L2')
    vertex_values_u_D = u_D.compute_vertex_values(mesh)
    vertex_values_u = u.compute_vertex_values(mesh)
    error_C = np.max(np.abs(vertex_values_u - vertex_values_u_D))
    print("L2_error=", error_L2)
    print("C_error=", error_C)
        
    # Plot and export solution
    plot(u, interactive=True)
    #plot(mesh)
    file = File("helmhurts2.pvd")
    file << u
    return u

def heat_equation_1():
    T = 2.0
    num_steps = 4
    dt = T/num_steps
    alpha = 3
    beta = 1.2
    t=0
    u_0 = Expression('1 + x[0]*x[0] + alpha*x[1]*x[1]',
degree=2, alpha=alpha, beta=beta)
    loc_f = u_0/dt+beta-2-2*alpha
    for i in range(num_steps):
	t+=dt
	sol = helmgoltz_1(Expression('1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t', alpha=alpha, beta=beta, t=t, degree=2), loc_f, 1/dt)
  	plt.figure()
	z = np.asarray([sol(point) for point in mesh_coordinates])
	plt.tripcolor(triangulation, z, edgecolors='k')
	plt.savefig('image'+str(i)+'.png')
	loc_f = interpolate(sol,V)/dt+beta-2-2*alpha
    seq = []
    for i in range(num_steps):
        seq = seq+[Image.open('image'+str(i)+'.png')]
	seq[i] = seq[i].convert('P')
    seq[0].save("animation.gif", save_all=True, append_images=seq, duration = 2000,loop = 0)


def heat_equation_2():
    T = 2.0
    num_steps = 2
    dt = T/num_steps
    alpha = 3
    beta = 1.2
    t=0
    u_0 = Expression('1 + x[0]*x[0] + alpha*x[1]*x[1]',
degree=2, alpha=alpha, beta=beta)
    loc_f = u_0/dt+beta-2-2*alpha
    for i in range(num_steps):
	t+=dt
	sol = helmgoltz_2(Expression('1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t', alpha=alpha, beta=beta, t=t, degree=2),loc_f, Expression('2*x[0]+2*alpha*x[1]',alpha=alpha,degree=2), 1/dt)
	loc_f = interpolate(sol,V)/dt+beta-2-2*alpha
     seq = []
    for i in range(num_steps):
        seq = seq+[Image.open('image'+str(i)+'.png')]
	seq[i] = seq[i].convert('P')
    seq[0].save("animation.gif", save_all=True, append_images=seq, duration = 2000,loop = 0)




if __name__ == '__main__':
    flag = int(sys.argv[1])
    domain = Circle(Point(0.0,0.0),1.0)
    mesh = generate_mesh(domain, 64)
    n = mesh.num_vertices()
    d = mesh.geometry().dim()
    mesh_coordinates = mesh.coordinates().reshape((n, d))
    triangles = np.asarray([cell.entities(0) for cell in cells(mesh)])
    triangulation = tri.Triangulation(mesh_coordinates[:, 0],
                                  mesh_coordinates[:, 1],
                                  triangles)
    V = FunctionSpace(mesh, 'P', 1)
    if flag == 1:
        helmgoltz_1(Expression('1 + x[0]*x[0] + 2*x[1]*x[1]', degree=2), Expression('8+2*x[0]*x[0]+4*x[1]*x[1]', degree=2), 2)
    if flag == 2:
        helmgoltz_2(Expression('1 + x[0]*x[0] + 2*x[1]*x[1]', degree=2), Expression('8+2*x[0]*x[0]+4*x[1]*x[1]', Expression('2*x[0]+4*x[1]'), degree=2), 2)
    if flag == 3:
        heat_equation_1()
    if flag == 4:
        heat_equation_2()

